\documentclass[12pt]{article}
\input{preambule.tex}

\begin{document}

\title{Rapport de Simulation}

\author{
    Glineur Pierre \\
    Matricule1 \and
    Tiako Ngouadje Cardin Patson \\
    Matricule2
    }
\date{\today}
\maketitle

\tableofcontents
\newpage

\section{Exécution}
Cette section détaille la structure du projet et la marche à suivre pour reproduire nos résultats.

\subsection{Structure du projet}
Le projet est organisé selon l'architecture suivante :

\subsubsection{Composants réseau (racine du projet)}
\begin{itemize}
    \item \textbf{Host.py} : Classe représentant les nœuds hôtes (émetteurs et récepteurs) avec implémentation des protocoles de fiabilité (modes 2 à 5).
    \item \textbf{Router.py} : Classe pour les routeurs, gérant l'acheminement et la file d'attente des paquets.
    \item \textbf{NIC.py} : Interface réseau (Network Interface Card) pour chaque hôte.
    \item \textbf{Link.py} : Classe représentant les liaisons réseau avec paramètres de délai, bande passante et probabilité de perte.
    \item \textbf{Packet.py} : Structure des paquets échangés.
\end{itemize}

\subsubsection{Moteur de simulation (dossier \texttt{simulator/})}
Le moteur de simulation discret est composé de :
\begin{itemize}
    \item \textbf{Simulator.py} : Cœur du moteur gérant la file d'événements et l'horloge globale.
    \item \textbf{SimulatedEntity.py} : Classe de base pour toutes les entités du réseau.
    \item \textbf{Event.py} et \textbf{SimulatorEvent.py} : Gestion des événements de simulation.
\end{itemize}

\subsubsection{Scripts de test et analyse (racine du projet)}
\begin{itemize}
    \item \textbf{mode2acquittements.py} : Simulation du Mode 2 (Stop-and-Wait avec accusés de réception).
    \item \textbf{mode3avecretransmission.py} : Simulation du Mode 3 (Stop-and-Wait avec timer et retransmission).
    \item \textbf{mode4pipelining.py} : Simulation du Mode 4 (Pipelining avec fenêtre fixe).
    \item \textbf{mode5\_dynamique\_50.py} : Simulation du Mode 5 (Pipelining avec fenêtre dynamique, adaptée aux variations de réseau).
    \item \textbf{run\_simulation\_mod\_packet\_exchange.py} : Script pour analyser différents scénarios et générer des logs détaillés.
    \item \textbf{example.py} : Exemple de configuration simple pour démarrer avec le simulateur.
\end{itemize}

\subsection{Instructions de reproduction}
Pour reproduire les scénarios décrits dans ce rapport, exécutez les scripts suivants à la racine du projet en utilisant la commande :
\begin{verbatim}
python <nom_du_script>.py
\end{verbatim}

\subsubsection{Scénarios de test}
Les cinq modes de transmission sont testables indépendamment :

\begin{itemize}
    \item \textbf{Mode 2} : \verb|python mode2acquittements.py|
    \begin{itemize}
        \item Implémente le protocole Stop-and-Wait avec accusés de réception (ACK).
        \item Pas de mécanisme de timeout ; la simulation bloque en cas de perte.
        \item Utile pour démontrer les limitations du protocole rdt 2.2.
    \end{itemize}
    
    \item \textbf{Mode 3} : \verb|python mode3avecretransmission.py|
    \begin{itemize}
        \item Étend le Mode 2 avec un timer et retransmission automatique.
        \item Démontre le protocole rdt 3.0 avec gestion des timeouts.
        \item Robustesse accrue face aux pertes de paquets.
    \end{itemize}
    
    \item \textbf{Mode 4} : \verb|python mode4pipelining.py|
    \begin{itemize}
        \item Implémente le Pipelining avec fenêtre de transmission fixe.
        \item Améliore le débit en envoyant plusieurs paquets sans attendre les ACKs.
        \item Fenêtre pré-configurée pour éviter la saturation du réseau.
    \end{itemize}
    
    \item \textbf{Mode 5} : \verb|python mode5_dynamique_50.py|
    \begin{itemize}
        \item Pipelining avec fenêtre dynamique (inspiré de TCP Congestion Control).
        \item La fenêtre s'adapte automatiquement en fonction des ACKs reçus et des timeouts.
        \item Optimisation du débit tout en évitant la congestion du réseau.
    \end{itemize}
\end{itemize}

\subsubsection{Script d'analyse globale}
Pour une analyse complète comparant plusieurs scénarios :
\begin{verbatim}
python run_simulation_mod_packet_exchange.py
\end{verbatim}
Ce script génère des logs détaillés permettant d'analyser les performances de chaque mode et de comparer les résultats.

\section{Implémentation}
\subsection{Approche choisie}
Notre implémentation repose sur l'extension de la classe Host pour gérer les mécanismes de fiabilité décrits dans le chapitre 3 du cours (Transport Layer). Nous avons mis en place :
\begin{itemize}
    \item Le Frigo (\_unacked\_packets) : Gestion de la fenêtre glissante.
    \item Le Buffer (\_buffer) : File d'attente logicielle pour le stockage des paquets en attente de fenêtre libre.
    \item Le Timer unique : Implémentation du protocole rdt 3.0 avec un décompte pour le paquet le plus ancien.
\end{itemize}

\subsubsection{Détails d'implémentation par mode}

\paragraph{Gestion générale de la fenêtre et du buffer :}
L'initialisation de la classe Host crée les structures de données essentielles :
\begin{verbatim}
self._unacked_packets = []    # Le "Frigo"
self._buffer = []              # File d'attente
self._window_size = 1          # Taille fenêtre
self._timer_pending = False
self._timeout_duration = 0.5   # Délai timeout
\end{verbatim}
La méthode send() décide d'envoyer immédiatement ou de placer en buffer selon l'état de la fenêtre :
\begin{verbatim}
if len(self._unacked_packets) < self._window_size:
    self._transmit_packet(pkt)  # Envoyer
else:
    self._buffer.append(pkt)    # Buffer plein, attendre
\end{verbatim}

\paragraph{Modes 2 \& 3 (Stop-and-Wait) :} Les deux modes utilisent une fenêtre fixe de taille 1. L'émetteur envoie un paquet et doit attendre l'ACK avant de poursuivre. La différence fondamentale réside dans le timer :

\subparagraph{Mode 2 (ACK simple) :} Pas de timer, le code retourne sans action :
\begin{verbatim}
def _start_timer(self):
    if self._mode == ReliabilityMode.ACKNOWLEDGES:
        return  # En mode 2, pas de timer
    # ... suite du code
\end{verbatim}
Si un paquet est perdu, la simulation attend indéfiniment l'ACK.

\subparagraph{Mode 3 (Retransmission) :} Le timer est armé lors de chaque envoi. À l'expiration, la méthode \_on\_timeout() retransmet :
\begin{verbatim}
def _on_timeout(self):
    if self._unacked_packets:
        oldest_pkt = self._unacked_packets[0]
        self.info(f'Timer expired!')
        self._nic.send(oldest_pkt)  # Retransmettre
        self._timer_pending = False
        self._start_timer()  # Réarmer le timer
\end{verbatim}

\paragraph{Modes 4 \& 5 (Pipelining) :} L'émetteur envoie plusieurs paquets dans une fenêtre de transmission avant d'attendre les ACKs.

\subparagraph{Mode 4 (Fenêtre fixe) :} La fenêtre a une taille pré-définie et constante (ex. 4 paquets). Si la fenêtre est pleine, les nouveaux paquets sont stockés dans le buffer.

\subparagraph{Mode 5 (Fenêtre dynamique) :} La fenêtre débute à 1 et augmente d'un paquet à chaque ACK reçu, mimant le comportement TCP. En cas de timeout, elle réinitialise à 1 :
\begin{verbatim}
if self._mode == ReliabilityMode.PIPELINING_DYNAMIC_WINDOW:
    self._window_size += 1  # Augmente à chaque ACK
    
# En cas de timeout :
if self._mode == ReliabilityMode.PIPELINING_DYNAMIC_WINDOW:
    self._window_size = 1   # Retour à 1 (congestion)
\end{verbatim}

\paragraph{Gestion des ACKs cumulatifs :} Lors de la réception d'un ACK, la méthode receive() supprime du frigo tous les paquets ayant un numéro de séquence inférieur ou égal (comportement cumulatif) :
\begin{verbatim}
# Supprimer le paquet et tous les précédents (cumulatif)
self._unacked_packets = [p for p in self._unacked_packets 
                         if p.serial_number > pkt.serial_number]
\end{verbatim}
Cela permet d'acquitter implicitement plusieurs paquets en un seul ACK.

\paragraph{Synchronisation du buffer et de la fenêtre :} À la réception d'un ACK, une boucle extrait du buffer les paquets en attente, tant que l'espace dans la fenêtre est disponible :
\begin{verbatim}
while self._buffer and len(self._unacked_packets) < self._window_size:
    next_pkt = self._buffer.pop(0)
    self._transmit_packet(next_pkt)  # Reprendre transmission
\end{verbatim}
Cela maintient un flot continu de transmissions sans surcharger le frigo.

\subsection{Difficultés rencontrées}
\begin{itemize}
    \item Gestion des ACKs cumulatifs : S'assurer que la réception d'un ACK libère correctement tous les paquets précédents du "frigo".
    \item Synchronisation du Timer : Éviter les redondances de timers lors de l'envoi rapide de plusieurs paquets en mode Pipelining.
\end{itemize}

\subsection{État final}
L'implémentation supporte les 5 modes demandés. Les modes 2 et 3 fonctionnent en Stop-and-Wait, tandis que les modes 4 et 5 exploitent le Pipelining pour optimiser l'utilisation de la bande passante.

\section{Simulations}
\subsection{Analyse des résultats et réponses aux questions de l'énoncé}
\subsubsection{Stop and Wait (Modes 2 \& 3)}
\begin{itemize}
    \item Mode 2 (ACK) : Sans timer, nous observons que la simulation se bloque indéfiniment en cas de perte (Lien L1 avec lost\_prob \> 0). Cela illustre les limites du protocole rdt 2.2 décrit aux pages 34-40 du cours.
    \item Mode 3 (Retransmission) : Le log montre @0.500000 Timer expired! Retransmitting. L'émetteur détecte la perte et survit à l'incident.
    \item Temps moyen de transmission : [Insérez votre calcul ici : Moyenne des temps entre sends et received ACK].
\end{itemize}
\subsubsection{Pipelining avec fenêtre fixe (Mode 4)}
\begin{itemize}
    \item Observations : Contrairement au mode 3, l'émetteur envoie plusieurs paquets (fenêtre de 4) dès t=0.000000 sans attendre les premiers ACKs.
    \item Comparaison : Le temps moyen de transmission diminue drastiquement car le lien ne reste pas inactif durant le temps de propagation (RTT).
\end{itemize}
\subsubsection{Pipelining avec fenêtre dynamique (Mode 5)}
\begin{itemize}
    \item Comportement attendu : La fenêtre commence à 1, augmente à chaque ACK, et chute à 1 en cas de timeout.
    \item Analyse du Goulot : Avec un lien L2 à 500 kbps et une file au routeur de 10, nous observons une congestion.
    \item Débit moyen effectif : il faudra Insérer le calcul : (Paquets * Taille * 8) / Temps total.
    \item Justification : L'ajustement dynamique permet de trouver le débit maximal du lien critique (500 kbps) sans saturer indéfiniment le routeur.
\end{itemize}
\section{Conclusion}

\subsection{Synthèse des résultats}
La comparaison entre les modes fixe (Mode 4) et dynamique (Mode 5) démontre que l'approche dynamique est plus résiliente et efficace pour s'adapter aux variations des capacités réseau. Le Mode 5, inspiré du contrôle de congestion TCP, ajuste la taille de la fenêtre en réaction aux ACKs reçus et aux timeouts, permettant une meilleure utilisation de la bande passante tout en évitant la saturation des files d'attente intermédiaires.

\subsection{Perspectives d'évolution}

\subsubsection{Amélioration du Mode 5 avec l'algorithme VEGAS}
Le protocole TCP VEGAS introduit une détection de congestion proactive basée sur la mesure du \textit{Round-Trip Time} (RTT) plutôt que sur les pertes de paquets. Cet algorithme serait particulièrement bénéfique dans les scénarios à forte probabilité de perte (chaos) :

\begin{itemize}
    \item \textbf{Détection précoce :} VEGAS mesure l'écart entre le RTT attendu (minimum observé) et le RTT actuel. Une augmentation du RTT signale une congestion avant même qu'il y ait des pertes. Cela permettrait au Mode 5 de réduire la fenêtre de manière préventive.
    
    \item \textbf{Réduction du nombre de retransmissions :} En évitant les timeouts coûteux, VEGAS réduit les pics de congestion causés par les retransmissions, ce qui diminue le risque de pertes en cascade.
    
    \item \textbf{Mécanisme proposé :}
\begin{verbatim}
expected_throughput = window_size / min_rtt
actual_throughput = packets_acked / current_rtt
diff = expected_throughput - actual_throughput

if diff > threshold_high:
    window_size -= 1  # Congestion détectée
elif diff < threshold_low:
    window_size += 1  # Réseau disponible
\end{verbatim}
\end{itemize}

\subsubsection{Gestion améliorée dans les réseaux chaotiques}
Pour les scénarios avec probabilités élevées de perte (chaos), plusieurs améliorations sont envisageables :

\begin{itemize}
    \item \textbf{Adaptation du timeout :} Au lieu d'un timeout fixe (0.5s), implémenter un timeout adaptatif basé sur le RTT mesurer. Cela réduit les faux timeouts et les retransmissions inutiles.
    
    \item \textbf{Mode Slow-Start amélioré :} Après un timeout, débuter une phase de Slow-Start (doubler la fenêtre chaque RTT) jusqu'à une limite prédéfinie, permettant une reprise plus rapide après une congestion.
    
    \item \textbf{Redondance sélective :} Envoyer certains paquets critiques plusieurs fois avec de petits délais, réduisant la probabilité qu'un paquet soit perdu au moins une fois.
\end{itemize}

\subsubsection{Extension à d'autres protocoles}
\begin{itemize}
    \item \textbf{Mode 6 : Pipelining avec VEGAS :} Implémenter un Mode 6 combinant le Pipelining dynamique avec la détection RTT de VEGAS. Cela offrirait une meilleure performance dans les réseaux variables.
    
    \item \textbf{Mode 7 : Contrôle de congestion Multi-flux :} Pour les topologies multi-source, implémenter une négociation de bande passante équitable inspirée de TCP Reno ou CUBIC.
\end{itemize}

\subsection{Conclusion générale}
Ce projet a démontré l'importance de l'adaptation dynamique dans les protocoles de transport. Alors que le Mode 4 (fenêtre fixe) offre la simplicité, le Mode 5 (fenêtre dynamique) prouve son efficacité face à la variabilité réseau. L'intégration de concepts avancés comme VEGAS promettrait une résilience accrue dans les environnements chaotiques, où les pertes de paquets et la congestion sont fréquentes. L'évolution vers des algorithmes proactifs plutôt que réactifs représente la voie naturelle pour l'optimisation continue des protocoles de transmission fiable.
\end{document}