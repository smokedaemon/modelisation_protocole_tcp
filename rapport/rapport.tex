\documentclass[12pt]{article}
\input{preambule.tex}

\begin{document}

\title{Rapport de Simulation}

\author{
    Glineur Pierre \\
    244618 \and
    Tiako Ngouadje Cardin Patson \\
    250982
    }
\date{\today}
\maketitle

\tableofcontents
\newpage

\section{Exécution}

\subsection{Structure du projet}
Le projet est organisé selon l'architecture suivante :

\subsubsection{Composants réseau (racine du projet)}
\begin{itemize}
    \item \textbf{Host.py} : Classe représentant les nœuds hôtes (émetteurs et récepteurs) avec implémentation des protocoles de fiabilité (modes 2 à 5).
    \item \textbf{Router.py} : Classe pour les routeurs, gérant l'acheminement et la file d'attente des paquets.
    \item \textbf{NIC.py} : Interface réseau (Network Interface Card) pour chaque hôte.
    \item \textbf{Link.py} : Classe représentant les liaisons réseau avec paramètres de délai, bande passante et probabilité de perte.
    \item \textbf{Packet.py} : Structure des paquets échangés.
\end{itemize}

\subsubsection{Moteur de simulation (dossier \texttt{simulator/})}
Le moteur de simulation discret est composé de :
\begin{itemize}
    \item \textbf{Simulator.py} : Cœur du moteur gérant la file d'événements et l'horloge globale.
    \item \textbf{SimulatedEntity.py} : Classe de base pour toutes les entités du réseau.
    \item \textbf{Event.py} et \textbf{SimulatorEvent.py} : Gestion des événements de simulation.
\end{itemize}

\subsubsection{Scripts de test et analyse (racine du projet)}
\begin{itemize}
    \item \textbf{mode2acquittements.py} : Simulation du Mode 2 (Stop-and-Wait avec accusés de réception).
    \item \textbf{mode3avecretransmission.py} : Simulation du Mode 3 (Stop-and-Wait avec timer et retransmission).
    \item \textbf{mode4pipelining.py} : Simulation du Mode 4 (Pipelining avec fenêtre fixe).
    \item \textbf{mode5\_dynamique\_50.py} : Simulation du Mode 5 (Pipelining avec fenêtre dynamique, adaptée aux variations de réseau).
    \item \textbf{run\_simulation\_mod\_packet\_exchange.py} : Script pour analyser différents scénarios et générer des logs détaillés.
    % \item \textbf{example.py} : Exemple de configuration simple pour démarrer avec le simulateur.
\end{itemize}

\subsection{Instructions de reproduction}
Pour reproduire les scénarios décrits dans ce rapport, exécutez les scripts suivants à la racine du projet en utilisant la commande :
\begin{verbatim}
python <nom_du_script>.py
\end{verbatim}

\subsubsection{Scénarios de test}
Les cinq modes de transmission sont testables indépendamment :

\begin{itemize}
    \item \textbf{Mode 2} : \verb|python mode2acquittements.py|
    \begin{itemize}
        \item Implémente le protocole Stop-and-Wait avec accusés de réception (ACK).
        \item Pas de mécanisme de timeout ; la simulation bloque en cas de perte.
        \item Utile pour démontrer les limitations du protocole rdt 2.2.
    \end{itemize}
    
    \item \textbf{Mode 3} : \verb|python mode3avecretransmission.py|
    \begin{itemize}
        \item Étend le Mode 2 avec un timer et retransmission automatique.
        \item Démontre le protocole rdt 3.0 avec gestion des timeouts.
        \item Robustesse accrue face aux pertes de paquets.
    \end{itemize}
    
    \item \textbf{Mode 4} : \verb|python mode4pipelining.py|
    \begin{itemize}
        \item Implémente le Pipelining avec fenêtre de transmission fixe.
        \item Améliore le débit en envoyant plusieurs paquets sans attendre les ACKs.
        \item Fenêtre pré-configurée pour éviter la saturation du réseau.
    \end{itemize}
    
    \item \textbf{Mode 5} : \verb|python mode5_dynamique_50.py|
    \begin{itemize}
        \item Pipelining avec fenêtre dynamique (inspiré de TCP Congestion Control).
        \item La fenêtre s'adapte automatiquement en fonction des ACKs reçus et des timeouts.
        \item Optimisation du débit tout en évitant la congestion du réseau.
    \end{itemize}
\end{itemize}

\subsubsection{Script d'analyse globale}
Pour une analyse complète comparant plusieurs scénarios :
\begin{verbatim}
python run_simulation_mod_packet_exchange.py
\end{verbatim}
Ce script génère des logs détaillés permettant d'analyser les performances de chaque mode et de comparer les résultats.

\section{Implémentation}
\subsection{Approche choisie}
Notre implémentation repose sur l'extension de la classe Host pour gérer les mécanismes de fiabilité décrits dans le chapitre 3 du cours (Transport Layer). Nous avons mis en place :
\begin{itemize}
    \item Le Frigo (\_unacked\_packets) : Gestion de la fenêtre glissante.
    \item Le Buffer (\_buffer) : File d'attente logicielle pour le stockage des paquets en attente de fenêtre libre.
    \item Le Timer unique : Implémentation du protocole rdt 3.0 avec un décompte pour le paquet le plus ancien.
\end{itemize}

\subsubsection{Détails d'implémentation par mode}

\paragraph{Gestion générale de la fenêtre et du buffer :}
L'initialisation de la classe Host crée les structures de données essentielles :
\begin{verbatim}
self._unacked_packets = []    # Le "Frigo"
self._buffer = []              # File d'attente
self._window_size = 1          # Taille fenêtre
self._timer_pending = False
self._timeout_duration = 0.5   # Délai timeout
\end{verbatim}
La méthode send() décide d'envoyer immédiatement ou de placer en buffer selon l'état de la fenêtre :
\begin{verbatim}
if len(self._unacked_packets) < self._window_size:
    self._transmit_packet(pkt)  # Envoyer
else:
    self._buffer.append(pkt)    # Buffer plein, attendre
\end{verbatim}

\paragraph{Mode 2 (Stop-and-Wait avec ACKs) :} Protocole rdt 2.2 sans timeout. Fenêtre=1, l'émetteur attend l'ACK avant d'envoyer le suivant.

\textit{Code clé :}
\begin{verbatim}
if self._mode == ReliabilityMode.ACKNOWLEDGES:
    return  # Pas de timer en mode 2
\end{verbatim}

\textit{Impact logs :} Frigo vide, mais blocage en cas de perte d'ACK (pas de retransmission).

\paragraph{Mode 3 (Stop-and-Wait avec Retransmission) :} Ajoute le timer (rdt 3.0). À l'expiration (0.5s), retransmet le paquet le plus ancien.

\paragraph{Mode 4 (Pipelining avec fenêtre fixe) :} Envoie plusieurs paquets (fenêtre=4) sans attendre les ACKs. Utilise les ACKs cumulatifs pour acquitter plusieurs paquets en un seul message.

\paragraph{Mode 5 (Pipelining avec fenêtre dynamique) :} La fenêtre croît après chaque ACK (Slow Start, Additive Increase). En timeout, elle réinitialise à 1 (Multiplicative Decrease). Découvre automatiquement la capacité réseau.

\textit{Code clé :}
\begin{verbatim}
# Gestion de la fenêtre dynamique (Section 2.2 / Mode 5)
if self._mode == ReliabilityMode.PIPELINING_DYNAMIC_WINDOW:
    self._window_size += 1
    self.info(f'Window size increased to {self._window_size}')

\end{verbatim}

\subsubsection{Diagrammes de séquence des modes (résumés)}

\paragraph{Mode 2 : Stop-and-Wait (sans timeout)} 
\begin{verbatim}
Host A          Network          Host B
  |               |               |
  |--DATA SN=1--->|--DATA SN=1--->|
  | (attente)     | (attente)     | Envoie ACK 1
  |<--ACK SN=1----|<--ACK SN=1----|
  |               |               |
  |--DATA SN=2--->|--DATA SN=2--->|
  |     X ACK 2 PERDU             |
  | (BLOQUÉ indéfiniment)         |
\end{verbatim}

\paragraph{Mode 3 : Avec timeout et retransmission}
\begin{verbatim}
Host A          Network          Host B
  |--DATA SN=6--->|--DATA SN=6--->|
  |[Timer=0.5s]   |    X PERDU     |
  | @0.5s TIMEOUT |                |
  |--DATA SN=6--->|--DATA SN=6--->|
  |<--ACK SN=6----|<--ACK SN=6----|
  |               |                |
\end{verbatim}

\paragraph{Mode 4 : Pipelining fenêtre=4}
\begin{verbatim}
Host A          Network          Host B
  |--DATA 1,2,3,4-->|            |
  |[Fenêtre pleine] |--1,2,3,4-->|
  |<--ACK 1---------|<--ACK 1-----|
  |--DATA 5-------->|            |
  |[ACK cumulatif]  | X ACK 3     |
  |<--ACK 4---------|<--ACK 4-----|
  |[Acquitte aussi 3]|            |
\end{verbatim}

\paragraph{Mode 5 : Pipelining dynamique (Slow Start)}
\begin{verbatim}
Host A          Network          Host B
Fenêtre=1
  |--DATA 1-------->|--DATA 1--->|
  |<--ACK 1---------|<--ACK 1-----|
  | Fenêtre: 1->2   |             |
  |--DATA 2,3------>|--2,3------->|
  |<--ACK 2---------|<--ACK 2-----|
  | Fenêtre: 2->3   |             |
  | ... Croissance progressive    |
  | jusqu'à saturation (500kbps)  |
\end{verbatim}

\subsection{Difficultés rencontrées}
\begin{itemize}
    \item Gestion des ACKs cumulatifs : S'assurer que la réception d'un ACK libère correctement tous les paquets précédents du "frigo".
    \item Synchronisation du Timer : Éviter les redondances de timers lors de l'envoi rapide de plusieurs paquets en mode Pipelining.
    \item Prise en main du language python afin de changer le comportement de l'objet Host.py.
\end{itemize}

\subsection{État final}
L'implémentation supporte les 5 modes demandés. Les modes 2 et 3 fonctionnent en Stop-and-Wait, tandis que les modes 4 et 5 exploitent le Pipelining pour optimiser l'utilisation de la bande passante. Elle contient aussi des nouveaux logs pour rendre le comportement de l'application plus clair.

\section{Simulations}
\subsection{Analyse des résultats et réponses aux questions de l'énoncé}

On considère 
\begin{itemize}
    \item \textbf{Débit Moyen effectif} : Rapport entre le volume total de données et le temps total entre le premier envoi du paquet et la réception du dernier ACK
    \item \textbf{Délai moyen} : Rapport entre le temps total et le nombre de paquet transmis
    \item \textbf{Taux de retransmission} : Nombre de paquet réellement transmis
\end{itemize}
\subsubsection{Mode 2 : Stop-and-Wait avec ACKs}
\textit{Logs : logs\_mode2.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Séquence stricte} : Un seul paquet par fenêtre (taille=1). À $t=0.000000$, l'Hôte A envoie SN=1. Il n'attend pas l'ACK avant de décider d'envoyer le suivant : contrairement au Mode 1 sans fiabilité, le frigo impose d'attendre la confirmation.
    \item \textbf{Frigo contrôlé} : Frigo status : 0 packets pending montre que le système s'assure qu'un seul paquet reste "en vol" à la fois. Cela garantit qu'aucun débordement de file d'attente ne se produit au niveau du routeur.
    \item \textbf{Blocage en cas de perte} : À $t=0.001691$, l'ACK SN=6 est perdu. Sans timeout (protocole rdt 2.2), l'émetteur reste bloqué indéfiniment dans l'état "Wait for ACK".
    \item \textbf{Absence de mécanisme de retransmission} : Ben que ce mode soit plus ordonné, il reste vulnérable aux pertes de paquets sur le lien. Si le paquet SN=1 ou son ACK était perdu, l'émetteur resterait bloqué indéfiniment dans l'état "Wait for ACK", car le mécanisme de Timer n'est introduit qu'avec le rdt 3.0
\end{itemize}

\paragraph{Calculs de Performance :}

\textit{1. Débit Moyen Effectif :}
\begin{itemize}
    \item Données : 10 paquets $\times$ 10 octets $\times$ 8bits/octects = 800 bits
    \item Temps : 0.000000 à 0.002840 s (réception du dernier ACK pour SN = 10) = 0.002840 s
    \item \textbf{Débit} : $\frac{800}{0.002840} \approx 282$ kbps
\end{itemize}

\textit{2. Délai Moyen :}  
\begin{itemize}
    \item Total des délais / 10 $\approx 0.000284$ s (très rapide en l'absence de perte)
\end{itemize}

\textit{3. Retransmission :}
\begin{itemize}
    \item Taux : 0\% (aucune retransmission, pas de timer)
\end{itemize}

\paragraph{Débit effectif :} 282 kbps (sans perte) | Bloqué indéfiniment (avec perte ACK) | il est nettement inférieur au débit du lien le plus lent (500 kbps). Cette sous-utilisation du canal est caractéristique du Stop-and-Wait. L'émetteur passe la majeure partie de son temps en attente du feedback du récepteur plutôt qu'à transmettre des données utiles.

\subsubsection{Mode 3 : Stop-and-Wait avec Retransmission}
\textit{Logs : logs\_mode3.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Gestion des pertes} : À $t=0.001691$, l'ACK SN=6 est perdu sur le lien. Le système ne se bloque pas (contrairement au Mode 2), car un timer de 0.5s est armé lors de l'envoi.
    \item \textbf{Déclenchement du Countdown Timer} : À $t=0.500000$, le timer expire. Le log indique "Timer expired!" Cela se produit car le délai de retransmission (RTO) est proche du temps de traitement, provoquant des doublons que le récepteur gère grâce aux numéros de séquence le paquet SN=6 est automatiquement retransmis (rdt 3.0).
    \item \textbf{Retransmissions successives} : SN=6 est envoyé à $t=0.001021$ (initial), $t=0.500000$ (1ère retransmission), et $t=0.500284$ (2ème retransmission). Le système effectue plusieurs essais jusqu'à réception d'un ACK.
    \item \textbf{Coût du timeout} : Délai massif de 0.5s entre la détection de perte et la récupération. Cet effondrement du débit (1.6 kbps vs 282 kbps en Mode 2) justifie le passage au Pipelining (Modes 4-5).
\end{itemize}

\paragraph{Calculs de Performance :}


\textit{1. Débit Moyen Effectif :}
\begin{itemize}
    \item Données : 10 paquets $\times$ 10 octets $\times$ 8bits/octects = 800 bits
    \item Temps : 0.000000 à 0.501972 s = 0.501972 s
    \item \textbf{Débit} : $\frac{800}{0.501972} \approx 1.6$ kbps (\textit{fortement réduit par timeout})
\end{itemize}

\textit{2. Délai Moyen :}
\begin{itemize}
    \item Total des délais / 10 : $\approx 0.050$ s (dominé par le délai de SN=6 : $0.501972 - 0.001021 = 0.501$ s)
\end{itemize}

\textit{3. Retransmission :}
\begin{itemize}
    \item Taux : 20\% (2 retransmissions de SN=6 sur 10 transmissions initiales)
\end{itemize}

\paragraph{Débit :} 1.6 kbps | Perte coûteuse : timeout de 0.5s

\subsubsection{Mode 4 : Pipelining avec fenêtre fixe}
\textit{Logs : logs\_mode4.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Remplissage initial du pipeline} : Dès $t=0.000000$, l'Hôte A transmet les paquets SN=1, 2, 3, 4 sans attendre de confirmation intermédiaire. Cela démontre une fenêtre d'émission (swnd) de taille $N=4$, conforme au pipelining Go-Back-N décrit.
    \item \textbf{Glissement de la fenêtre} : À $t=0.000284$, la réception de l'ACK 1 libère une place dans le frigo (Frigo status : 3 packets pending [2, 3, 4]). L'Hôte A injecte immédiatement SN=5, maintenant le pipeline rempli.
    \item \textbf{Résilience via ACKs cumulatifs} : À $t=0.001071$, l'ACK SN=6 est perdu sur le lien L1. Contrairement au Mode 3, la simulation ne s'arrête pas : à $t=0.001244$, la réception de l'ACK SN=7 acquitte implicitement le paquet 6 (car les ACKs sont cumulatifs dans ce protocole, type Go-Back-N). Aucun timeout n'est requis.
    \item \textbf{Saturation du bottleneck} : La fenêtre fixe (taille 4) provoque une injection continue de paquets. L'analyse montre que le lien L2 (500 kbps) est saturé à $\sim 93\%$ d'utilisation, malgré la perte d'ACK.
\end{itemize}

\paragraph{Calculs de Performance :}

\textit{1. Débit Moyen Effectif :}
\begin{itemize}
    \item Données : 10 paquets $\times$ 10 octets $\times$ 8bits/octects = 800 bits
    \item Temps : 0.000000 à 0.001724 s (réception du dernier ACK pour SN = 10) = 0.001724 s
    \item \textbf{Débit} : $\frac{800}{0.001724} \approx 464$ kbps (2.8x plus rapide que Mode 3)
\end{itemize}

\textit{2. Délai Moyen :}
\begin{itemize}
    \item Total des délais / Nombre de SN : $\approx 0.0012$ s (pipelining réduit les délais)
\end{itemize}

\textit{3. Retransmission :}
\begin{itemize}
    \item Taux : 0\% (ACK cumulatifs récupèrent SN=6 sans timeout)
\end{itemize}

\paragraph{Débit :} $\sim 464$ kbps (2.8x plus rapide que Mode 3)

\subsubsection{Mode 5 : Pipelining avec fenêtre dynamique}
\textit{Logs : logs\_mode5.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Phase de croissance (Additive Increase)} : Au départ, la fenêtre vaut 1. À chaque ACK reçu, elle s'incrémente : 1 → 2 → 3 → 4 → 5 → 6 → 7 après les premiers ACKs. À $t=0.001707$, la fenêtre atteint une taille de 11, permettant d'injecter davantage de paquets dans le réseau pour maximiser l'utilisation de la bande passante.
    \item \textbf{Détection de saturation (Congestion)} : À $t=0.001744$, on observe le premier rejet au routeur : "NIC(Reth1) dropped Reth1". Cela indique que le débit d'entrée (L1 : 5 Mbps) est trop élevé pour le débit de sortie (L2 : 500 kbps). Le protocole détecte cette saturation et ajuste sa fenêtre.
    \item \textbf{Réaction au Timeout (Multiplicative Decrease)} : À $t=0.500000$, le timer expire pour le paquet SN=49. Conformément au cours (p. 148), l'Hôte réagit violemment : Window size reset to 1. Cette réduction drastique de la swnd permet au réseau de se décongestionner en arrêtant l'injection de données.
    \item \textbf{Adaptation dynamique} : Contrairement au Mode 4 (fenêtre fixe = 4), le Mode 5 n'a pas de configuration manuelle. Il découvre automatiquement que le bottleneck peut supporter environ 500 kbps en augmentant progressivement jusqu'à saturation, puis en réduisant en cas de perte. C'est le meilleur compromis entre efficacité et fluidité réseau.
\end{itemize}

\paragraph{Calculs de Performance :}

\textit{1. Débit Moyen Effectif :}
\begin{itemize}
    \item \textbf{Phase timeout} : 4000 bits / 0.500801 s $\equiv$ 8 kbps (avec timeout 0.5s au paquet SN=6)
    \item \textbf{Phase permanent} : Saturation observée $\approx$ 500 kbps (débit du bottleneck)
    \item \textbf{Moyenne globale} : $\approx 450$ kbps (incorpore temps de Slow Start + stabilisation)
\end{itemize}

\textit{2. Délai Moyen :}
\begin{itemize}
    \item SN=1 : 0.21 ms (fenêtre=1, lent)
    \item SN=4-7 : 1.2-1.86 ms (fenêtre 3-4, congestion détectée)
    \item SN=8-10 : 500 ms incluant timeout et récupération
    \item \textbf{Moyenne} : $\approx 20$ ms (en régime permanent, avant timeout)
\end{itemize}

\textit{3. Retransmission :}
\begin{itemize}
    \item Taux : $\approx 10\%$ (pertes de queue lors du Slow Start, puis stabilisation)
\end{itemize}

\paragraph{Débit :} $\sim 450$ kbps (meilleur compromis : adaptation + fiabilité)

\paragraph{Synthèse comparative :}
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Mode} & \textbf{Débit} & \textbf{Avantage} \\
\hline
Mode 2 & 282 kbps & Ordre de réception \\
Mode 3 & 157 kbps & Fiabilité (rdt 3.0) \\
Mode 4 & 380 kbps & Pipelining simple \\
Mode 5 & 450 kbps & Adaptation dynamique \\
\hline
\end{tabular}
\end{center}

\section{Conclusion}

\subsection{Synthèse des résultats}
La comparaison entre les modes fixe (Mode 4) et dynamique (Mode 5) démontre que l'approche dynamique est plus résiliente et efficace pour s'adapter aux variations des capacités réseau. Le Mode 5, inspiré du contrôle de congestion TCP, ajuste la taille de la fenêtre en réaction aux ACKs reçus et aux timeouts, permettant une meilleure utilisation de la bande passante tout en évitant la saturation des files d'attente intermédiaires.

\subsection{Perspectives d'évolution}

\subsubsection{Mode 5 amélioré : VEGAS}
TCP VEGAS propose une détection proactive de congestion basée sur le RTT (Round-Trip Time) plutôt que sur les pertes. Cela permettrait :
\begin{itemize}
    \item Réduire les timeouts en détectant l'augmentation du RTT avant la perte.
    \item Adapter dynamiquement le timeout au RTT mesuré au lieu de 0.5s fixe.
    \item Découvrir la capacité réseau plus rapidement en phase Slow Start.
\end{itemize}

\subsubsection{Extensions possibles}
\begin{itemize}
    \item \textbf{Mode 6} : Pipelining + détection VEGAS pour réseaux variables.
    \item \textbf{Mode 7} : Contrôle équitable multi-flux (TCP Reno/CUBIC).
\end{itemize}

\subsection{Conclusion générale}
Cette application en Python met en perspective l'évolution  de l'échange des paquets dans les communications internets, notamment dans le mode TCP et UDP.
\newline
Nous voyons un envoi  limité qui ne prends pas en compte les pertes de pacquets et les pertes d'acquittement ( voir mode 1 et page 15 a 20 du chapitre 3 ) , ensuite la creation des ACK pour rendre les échanges fiables ( le mode 2 et les pages 31 a 40 du chapitre 3 ) , une amélioration avec un timer dans le mode 3 ( les pages 40 a 52 du chapitre 3 ) et la création du pipeline qui permet l'envoi en paralléle mais qui crée une congestion ; cela suit la théorie selon les pages 54 a 70 et finalement les pages 143 a 157 du chapitre 3 pour la gestion de la congestion d'un pipeline. 
\end{document}