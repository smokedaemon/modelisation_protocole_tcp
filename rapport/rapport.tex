\documentclass[12pt]{article}
\input{preambule.tex}

\begin{document}

\title{Rapport de Simulation}

\author{
    Glineur Pierre \\
    Matricule1 \and
    Tiako Ngouadje Cardin Patson \\
    Matricule2
    }
\date{\today}
\maketitle

\tableofcontents
\newpage

\section{Exécution}
Cette section détaille la structure du projet et la marche à suivre pour reproduire nos résultats.

\subsection{Structure du projet}
Le projet est organisé selon l'architecture suivante :

\subsubsection{Composants réseau (racine du projet)}
\begin{itemize}
    \item \textbf{Host.py} : Classe représentant les nœuds hôtes (émetteurs et récepteurs) avec implémentation des protocoles de fiabilité (modes 2 à 5).
    \item \textbf{Router.py} : Classe pour les routeurs, gérant l'acheminement et la file d'attente des paquets.
    \item \textbf{NIC.py} : Interface réseau (Network Interface Card) pour chaque hôte.
    \item \textbf{Link.py} : Classe représentant les liaisons réseau avec paramètres de délai, bande passante et probabilité de perte.
    \item \textbf{Packet.py} : Structure des paquets échangés.
\end{itemize}

\subsubsection{Moteur de simulation (dossier \texttt{simulator/})}
Le moteur de simulation discret est composé de :
\begin{itemize}
    \item \textbf{Simulator.py} : Cœur du moteur gérant la file d'événements et l'horloge globale.
    \item \textbf{SimulatedEntity.py} : Classe de base pour toutes les entités du réseau.
    \item \textbf{Event.py} et \textbf{SimulatorEvent.py} : Gestion des événements de simulation.
\end{itemize}

\subsubsection{Scripts de test et analyse (racine du projet)}
\begin{itemize}
    \item \textbf{mode2acquittements.py} : Simulation du Mode 2 (Stop-and-Wait avec accusés de réception).
    \item \textbf{mode3avecretransmission.py} : Simulation du Mode 3 (Stop-and-Wait avec timer et retransmission).
    \item \textbf{mode4pipelining.py} : Simulation du Mode 4 (Pipelining avec fenêtre fixe).
    \item \textbf{mode5\_dynamique\_50.py} : Simulation du Mode 5 (Pipelining avec fenêtre dynamique, adaptée aux variations de réseau).
    \item \textbf{run\_simulation\_mod\_packet\_exchange.py} : Script pour analyser différents scénarios et générer des logs détaillés.
    \item \textbf{example.py} : Exemple de configuration simple pour démarrer avec le simulateur.
\end{itemize}

\subsection{Instructions de reproduction}
Pour reproduire les scénarios décrits dans ce rapport, exécutez les scripts suivants à la racine du projet en utilisant la commande :
\begin{verbatim}
python <nom_du_script>.py
\end{verbatim}

\subsubsection{Scénarios de test}
Les cinq modes de transmission sont testables indépendamment :

\begin{itemize}
    \item \textbf{Mode 2} : \verb|python mode2acquittements.py|
    \begin{itemize}
        \item Implémente le protocole Stop-and-Wait avec accusés de réception (ACK).
        \item Pas de mécanisme de timeout ; la simulation bloque en cas de perte.
        \item Utile pour démontrer les limitations du protocole rdt 2.2.
    \end{itemize}
    
    \item \textbf{Mode 3} : \verb|python mode3avecretransmission.py|
    \begin{itemize}
        \item Étend le Mode 2 avec un timer et retransmission automatique.
        \item Démontre le protocole rdt 3.0 avec gestion des timeouts.
        \item Robustesse accrue face aux pertes de paquets.
    \end{itemize}
    
    \item \textbf{Mode 4} : \verb|python mode4pipelining.py|
    \begin{itemize}
        \item Implémente le Pipelining avec fenêtre de transmission fixe.
        \item Améliore le débit en envoyant plusieurs paquets sans attendre les ACKs.
        \item Fenêtre pré-configurée pour éviter la saturation du réseau.
    \end{itemize}
    
    \item \textbf{Mode 5} : \verb|python mode5_dynamique_50.py|
    \begin{itemize}
        \item Pipelining avec fenêtre dynamique (inspiré de TCP Congestion Control).
        \item La fenêtre s'adapte automatiquement en fonction des ACKs reçus et des timeouts.
        \item Optimisation du débit tout en évitant la congestion du réseau.
    \end{itemize}
\end{itemize}

\subsubsection{Script d'analyse globale}
Pour une analyse complète comparant plusieurs scénarios :
\begin{verbatim}
python run_simulation_mod_packet_exchange.py
\end{verbatim}
Ce script génère des logs détaillés permettant d'analyser les performances de chaque mode et de comparer les résultats.

\section{Implémentation}
\subsection{Approche choisie}
Notre implémentation repose sur l'extension de la classe Host pour gérer les mécanismes de fiabilité décrits dans le chapitre 3 du cours (Transport Layer). Nous avons mis en place :
\begin{itemize}
    \item Le Frigo (\_unacked\_packets) : Gestion de la fenêtre glissante.
    \item Le Buffer (\_buffer) : File d'attente logicielle pour le stockage des paquets en attente de fenêtre libre.
    \item Le Timer unique : Implémentation du protocole rdt 3.0 avec un décompte pour le paquet le plus ancien.
\end{itemize}

\subsubsection{Détails d'implémentation par mode}

\paragraph{Gestion générale de la fenêtre et du buffer :}
L'initialisation de la classe Host crée les structures de données essentielles :
\begin{verbatim}
self._unacked_packets = []    # Le "Frigo"
self._buffer = []              # File d'attente
self._window_size = 1          # Taille fenêtre
self._timer_pending = False
self._timeout_duration = 0.5   # Délai timeout
\end{verbatim}
La méthode send() décide d'envoyer immédiatement ou de placer en buffer selon l'état de la fenêtre :
\begin{verbatim}
if len(self._unacked_packets) < self._window_size:
    self._transmit_packet(pkt)  # Envoyer
else:
    self._buffer.append(pkt)    # Buffer plein, attendre
\end{verbatim}

\paragraph{Mode 2 (Stop-and-Wait avec ACKs) :} Protocole rdt 2.2 sans timeout. Fenêtre=1, l'émetteur attend l'ACK avant d'envoyer le suivant.

\textit{Code clé :}
\begin{verbatim}
if self._mode == ReliabilityMode.ACKNOWLEDGES:
    return  # Pas de timer en mode 2
\end{verbatim}

\textit{Impact logs :} Frigo vide, mais blocage en cas de perte d'ACK (pas de retransmission).

\paragraph{Mode 3 (Stop-and-Wait avec Retransmission) :} Ajoute le timer (rdt 3.0). À l'expiration (0.5s), retransmet le paquet le plus ancien.

\paragraph{Mode 4 (Pipelining avec fenêtre fixe) :} Envoie plusieurs paquets (fenêtre=4) sans attendre les ACKs. Utilise les ACKs cumulatifs pour acquitter plusieurs paquets en un seul message.

\paragraph{Mode 5 (Pipelining avec fenêtre dynamique) :} La fenêtre croît après chaque ACK (Slow Start, Additive Increase). En timeout, elle réinitialise à 1 (Multiplicative Decrease). Découvre automatiquement la capacité réseau.

\subsubsection{Diagrammes de séquence des modes (résumés)}

\paragraph{Mode 2 : Stop-and-Wait (sans timeout)} 
\begin{verbatim}
Host A          Network          Host B
  |               |               |
  |--DATA SN=1--->|--DATA SN=1--->|
  | (attente)     | (attente)     | Envoie ACK 1
  |<--ACK SN=1----|<--ACK SN=1----|
  |               |               |
  |--DATA SN=2--->|--DATA SN=2--->|
  |     X ACK 2 PERDU             |
  | (BLOQUÉ indéfiniment)         |
\end{verbatim}

\paragraph{Mode 3 : Avec timeout et retransmission}
\begin{verbatim}
Host A          Network          Host B
  |--DATA SN=6--->|--DATA SN=6--->|
  |[Timer=0.5s]   |    X PERDU     |
  | @0.5s TIMEOUT |                |
  |--DATA SN=6--->|--DATA SN=6--->|
  |<--ACK SN=6----|<--ACK SN=6----|
  |               |                |
\end{verbatim}

\paragraph{Mode 4 : Pipelining fenêtre=4}
\begin{verbatim}
Host A          Network          Host B
  |--DATA 1,2,3,4-->|            |
  |[Fenêtre pleine] |--1,2,3,4-->|
  |<--ACK 1---------|<--ACK 1-----|
  |--DATA 5-------->|            |
  |[ACK cumulatif]  | X ACK 3     |
  |<--ACK 4---------|<--ACK 4-----|
  |[Acquitte aussi 3]|            |
\end{verbatim}

\paragraph{Mode 5 : Pipelining dynamique (Slow Start)}
\begin{verbatim}
Host A          Network          Host B
Fenêtre=1
  |--DATA 1-------->|--DATA 1--->|
  |<--ACK 1---------|<--ACK 1-----|
  | Fenêtre: 1->2   |             |
  |--DATA 2,3------>|--2,3------->|
  |<--ACK 2---------|<--ACK 2-----|
  | Fenêtre: 2->3   |             |
  | ... Croissance progressive    |
  | jusqu'à saturation (500kbps)  |
\end{verbatim}

\subsection{Difficultés rencontrées}
\begin{itemize}
    \item Gestion des ACKs cumulatifs : S'assurer que la réception d'un ACK libère correctement tous les paquets précédents du "frigo".
    \item Synchronisation du Timer : Éviter les redondances de timers lors de l'envoi rapide de plusieurs paquets en mode Pipelining.
\end{itemize}

\subsection{État final}
L'implémentation supporte les 5 modes demandés. Les modes 2 et 3 fonctionnent en Stop-and-Wait, tandis que les modes 4 et 5 exploitent le Pipelining pour optimiser l'utilisation de la bande passante.

\section{Simulations}
\subsection{Analyse des résultats et réponses aux questions de l'énoncé}

\subsubsection{Mode 2 : Stop-and-Wait avec ACKs}
\textit{Logs : logs\_mode2.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Séquence stricte} : Un seul paquet par fenêtre (taille=1).
    \item \textbf{Frigo contrôlé} : Status toujours vide après ACK reçu.
    \item \textbf{Blocage en cas de perte} : À $t=0.000911$, l'ACK est perdu, la simulation se bloque (pas de timeout, protocole rdt 2.2).
\end{itemize}

\paragraph{Débit :} $\sim 282$ kbps (sans perte) | Bloqué (avec perte)

\subsubsection{Mode 3 : Stop-and-Wait avec Retransmission}
\textit{Logs : logs\_mode3.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Timeout et retransmission} : À $t=0.001691$, l'ACK SN=6 est perdu. À $t=0.500000$, le timeout déclenche la retransmission qui réussit à $t=0.500568$ (rdt 3.0, pages 45-52).
    \item \textbf{Coût du timeout} : Délai massif de 0.5s entre la perte et la récupération.
\end{itemize}

\paragraph{Débit :} $\sim 157$ kbps (pénalisé par le timeout)

\subsubsection{Mode 4 : Pipelining avec fenêtre fixe}
\textit{Logs : logs\_mode4.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Envoi initial} : 4 paquets envoyés à $t=0.000000$ sans attendre d'ACK.
    \item \textbf{Glissement fenêtre} : À chaque ACK, une nouvelle place se libère pour un nouveau paquet.
    \item \textbf{ACKs cumulatifs} : À $t=0.001071$, l'ACK SN=6 est perdu, mais $t=0.001244$ l'ACK SN=7 acquitte aussi SN=6 implicitement (pas de timeout).
\end{itemize}

\paragraph{Débit :} $\sim 380$ kbps (2.4x plus rapide que Mode 3)

\subsubsection{Mode 5 : Pipelining avec fenêtre dynamique}
\textit{Logs : logs\_mode5.md}

\paragraph{Observations :}
\begin{itemize}
    \item \textbf{Slow Start} : Fenêtre croît : 1 → 2 → 3 → 4 → 5 → 6 → 7 après chaque ACK.
    \item \textbf{Découverte automatique} : Contrairement au Mode 4 (fenêtre fixe), trouve le débit optimal (500 kbps) en augmentant progressivement jusqu'à saturation.
    \item \textbf{Résilience} : En timeout, fenêtre réinitialise à 1 (Multiplicative Decrease, pages 143-157).
\end{itemize}

\paragraph{Débit :} $\sim 450$ kbps (meilleur compromis: adaptation + fiabilité)

\paragraph{Synthèse comparative :}
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Mode} & \textbf{Débit} & \textbf{Avantage} \\
\hline
Mode 2 & 282 kbps & Ordre de réception \\
Mode 3 & 157 kbps & Fiabilité (rdt 3.0) \\
Mode 4 & 380 kbps & Pipelining simple \\
Mode 5 & 450 kbps & Adaptation dynamique \\
\hline
\end{tabular}
\end{center}
\section{Conclusion}

\subsection{Synthèse des résultats}
La comparaison entre les modes fixe (Mode 4) et dynamique (Mode 5) démontre que l'approche dynamique est plus résiliente et efficace pour s'adapter aux variations des capacités réseau. Le Mode 5, inspiré du contrôle de congestion TCP, ajuste la taille de la fenêtre en réaction aux ACKs reçus et aux timeouts, permettant une meilleure utilisation de la bande passante tout en évitant la saturation des files d'attente intermédiaires.

\subsection{Perspectives d'évolution}

\subsubsection{Mode 5 amélioré : VEGAS}
TCP VEGAS propose une détection proactive de congestion basée sur le RTT (Round-Trip Time) plutôt que sur les pertes. Cela permettrait :
\begin{itemize}
    \item Réduire les timeouts en détectant l'augmentation du RTT avant la perte.
    \item Adapter dynamiquement le timeout au RTT mesuré au lieu de 0.5s fixe.
    \item Découvrir la capacité réseau plus rapidement en phase Slow Start.
\end{itemize}

\subsubsection{Extensions possibles}
\begin{itemize}
    \item \textbf{Mode 6} : Pipelining + détection VEGAS pour réseaux variables.
    \item \textbf{Mode 7} : Contrôle équitable multi-flux (TCP Reno/CUBIC).
\end{itemize}

\subsection{Conclusion générale}
Ce projet démontre l'importance de l'adaptation dynamique. Le Mode 5 (fenêtre dynamique) surpasse le Mode 4 (fenêtre fixe) en s'ajustant automatiquement aux capacités réseau. L'intégration d'algorithmes proactifs comme VEGAS (détection RTT) améliorerait encore la résilience dans les environnements chaotiques. L'évolution vers le contrôle de congestion TCP représente la voie naturelle pour optimiser les protocoles de transmission fiable.
\end{document}